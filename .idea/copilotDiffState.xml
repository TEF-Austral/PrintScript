<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/parser/src/main/kotlin/statement/enforcers/ColonEnforcer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/parser/src/main/kotlin/statement/enforcers/ColonEnforcer.kt" />
              <option name="originalContent" value="package statement.enforcers&#10;&#10;import parser.Parser&#10;import parser.result.SemanticError&#10;import parser.result.SemanticResult&#10;import parser.result.SemanticSuccess&#10;import type.CommonTypes&#10;&#10;class ColonEnforcer(&#10;    private val nextEnforcer: SemanticEnforcers,&#10;) : SemanticEnforcers {&#10;    override fun enforce(result: SemanticResult): SemanticResult {&#10;        val currentParser = result.getParser()&#10;        // Check if there are tokens left before peeking or consuming&#10;        if (!currentParser.hasNext() || isColon(currentParser) || !result.isSuccess()) {&#10;            return SemanticError(&#10;                &quot;Expected delimiter &quot; + result.message(),&#10;                result.identifier(),&#10;                result.dataType(),&#10;                result.initialValue(),&#10;                currentParser,&#10;            )&#10;        }&#10;        val parserResult = currentParser.consume(CommonTypes.DELIMITERS)&#10;        return nextEnforcer.enforce(&#10;            SemanticSuccess(&#10;                parserResult.message(),&#10;                result.identifier(),&#10;                result.dataType(),&#10;                result.initialValue(),&#10;                parserResult.getParser(),&#10;            ),&#10;        )&#10;    }&#10;&#10;    private fun isColon(currentParser: Parser): Boolean =&#10;        !currentParser.consume(CommonTypes.DELIMITERS).isSuccess() ||&#10;            (currentParser.hasNext() &amp;&amp; currentParser.peak()?.getValue() != &quot;:&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package statement.enforcers&#13;&#10;&#13;&#10;import parser.Parser&#13;&#10;import parser.result.SemanticError&#13;&#10;import parser.result.SemanticResult&#13;&#10;import parser.result.SemanticSuccess&#13;&#10;import type.CommonTypes&#13;&#10;&#13;&#10;class ColonEnforcer(&#13;&#10;    private val nextEnforcer: SemanticEnforcers,&#13;&#10;) : SemanticEnforcers {&#13;&#10;    override fun enforce(result: SemanticResult): SemanticResult {&#13;&#10;        val currentParser = result.getParser()&#13;&#10;        // Check if there are tokens left before peeking or consuming&#13;&#10;        if (!currentParser.hasNext() || isColon(currentParser) || !result.isSuccess()) {&#13;&#10;            return SemanticError(&#13;&#10;                &quot;Expected delimiter &quot; + result.message(),&#13;&#10;                result.identifier(),&#13;&#10;                result.dataType(),&#13;&#10;                result.initialValue(),&#13;&#10;                currentParser,&#13;&#10;            )&#13;&#10;        }&#13;&#10;        val parserResult = currentParser.consume(CommonTypes.DELIMITERS)&#13;&#10;        return nextEnforcer.enforce(&#13;&#10;            SemanticSuccess(&#13;&#10;                parserResult.message(),&#13;&#10;                result.identifier(),&#13;&#10;                result.dataType(),&#13;&#10;                result.initialValue(),&#13;&#10;                parserResult.getParser(),&#13;&#10;            ),&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun isColon(currentParser: Parser): Boolean =&#13;&#10;        !currentParser.consume(CommonTypes.DELIMITERS).isSuccess() ||&#13;&#10;            (currentParser.hasNext() &amp;&amp; currentParser.peak()?.getValue() != &quot;:&quot;)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/parser/src/main/kotlin/statement/enforcers/IdentifierEnforcer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/parser/src/main/kotlin/statement/enforcers/IdentifierEnforcer.kt" />
              <option name="originalContent" value="package statement.enforcers&#10;&#10;import parser.Parser&#10;import parser.result.SemanticError&#10;import parser.result.SemanticResult&#10;import parser.result.SemanticSuccess&#10;import type.CommonTypes&#10;&#10;class IdentifierEnforcer(&#10;    private val nextEnforcer: SemanticEnforcers,&#10;) : SemanticEnforcers {&#10;    override fun enforce(result: SemanticResult): SemanticResult {&#10;        val currentParser = result.getParser()&#10;        // Check hasNext before peeking or consuming&#10;        if (!currentParser.hasNext() || isIdentifier(currentParser) || !result.isSuccess()) {&#10;            return SemanticError(&#10;                &quot;Expected identifier &quot; + result.message(),&#10;                result.identifier(),&#10;                result.dataType(),&#10;                result.initialValue(),&#10;                currentParser,&#10;            )&#10;        }&#10;        val parserResult = currentParser.consume(CommonTypes.IDENTIFIER)&#10;        return nextEnforcer.enforce(&#10;            SemanticSuccess(&#10;                parserResult.message(),&#10;                currentParser.peak()!!,&#10;                result.dataType(),&#10;                result.initialValue(),&#10;                parserResult.getParser(),&#10;            ),&#10;        )&#10;    }&#10;&#10;    private fun isIdentifier(currentParser: Parser): Boolean =&#10;        !currentParser.consume(CommonTypes.IDENTIFIER).isSuccess()&#10;}&#10;" />
              <option name="updatedContent" value="package statement.enforcers&#13;&#10;&#13;&#10;import parser.Parser&#13;&#10;import parser.result.SemanticError&#13;&#10;import parser.result.SemanticResult&#13;&#10;import parser.result.SemanticSuccess&#13;&#10;import type.CommonTypes&#13;&#10;&#13;&#10;class IdentifierEnforcer(&#13;&#10;    private val nextEnforcer: SemanticEnforcers,&#13;&#10;) : SemanticEnforcers {&#13;&#10;    override fun enforce(result: SemanticResult): SemanticResult {&#13;&#10;        val currentParser = result.getParser()&#13;&#10;        // Check hasNext before peeking or consuming&#13;&#10;        if (!currentParser.hasNext() || isIdentifier(currentParser) || !result.isSuccess()) {&#13;&#10;            return SemanticError(&#13;&#10;                &quot;Expected identifier &quot; + result.message(),&#13;&#10;                result.identifier(),&#13;&#10;                result.dataType(),&#13;&#10;                result.initialValue(),&#13;&#10;                currentParser,&#13;&#10;            )&#13;&#10;        }&#13;&#10;        val parserResult = currentParser.consume(CommonTypes.IDENTIFIER)&#13;&#10;        return nextEnforcer.enforce(&#13;&#10;            SemanticSuccess(&#13;&#10;                parserResult.message(),&#13;&#10;                currentParser.peak()!!,&#13;&#10;                result.dataType(),&#13;&#10;                result.initialValue(),&#13;&#10;                parserResult.getParser(),&#13;&#10;            ),&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun isIdentifier(currentParser: Parser): Boolean =&#13;&#10;        !currentParser.consume(CommonTypes.IDENTIFIER).isSuccess()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>